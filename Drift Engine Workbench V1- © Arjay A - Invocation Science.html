<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>invocation Science — Drift Engine • Propegation and Echo</title>
  <style>
    :root{
      --bg:#070a0f; --bg2:#0b101a; --panel:#0f1626; --panel-2:#0c1321;
      --text:#eef3fb; --muted:#a7b7cc; --accent:#7ae1ff; --accent-2:#9be978;
      --warn:#ffd166; --bad:#ff6b6b; --good:#6be675; --ink:#0f1322; --grid:#152138;
      --radius:18px; --shadow:0 16px 50px rgba(0,0,0,.4);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1100px 800px at 75% 25%,#0f1730 0%,#0b0f19 55%,#070a0f 100%);
         color:var(--text);font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Arial,sans-serif}
    .app{display:grid;grid-template-columns:410px 1fr;gap:20px;height:100%;padding:18px}
    .panel{background:linear-gradient(180deg,var(--panel) 0%, var(--panel-2) 100%);
           border:1px solid #182540;border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden}
    .head{display:flex;align-items:center;gap:12px;padding:16px;border-bottom:1px solid #182540;background:linear-gradient(180deg,#101a33,#0e162b)}
    .head h1{font-size:18px;letter-spacing:.4px;margin:0;font-weight:750}
    .badge{font-size:11px;padding:4px 8px;border-radius:999px;background:#132137;border:1px solid #1d2a45;color:#8ccbf1}
    .controls{padding:14px 16px 18px 16px;display:flex;flex-direction:column;gap:14px;max-height:calc(100vh - 120px);overflow:auto}
    .group{border:1px solid #182540;border-radius:14px;background:#0e152a;padding:12px}
    .group h2{margin:0 0 8px 0;font-size:13px;font-weight:800;color:#cfe0ff;letter-spacing:.3px;text-transform:uppercase}
    .row{display:grid;grid-template-columns:1fr auto;gap:10px;align-items:center;margin:6px 0}
    .row label{font-size:12px;color:#c6d6e6}
    .row output{font-variant-numeric:tabular-nums;font-size:12px;color:#9fb2c8;min-width:56px;text-align:right}
    input[type=range]{width:100%}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    button{appearance:none;border:1px solid #203356;background:#15203a;color:#cfe7ff;padding:8px 10px;border-radius:10px;font-size:12px;cursor:pointer;transition:.2s}
    button:hover{filter:brightness(1.08)} button:active{transform:translateY(1px)}
    .btn-accent{background:linear-gradient(180deg,#123a57,#0e2a40);border-color:#1e4866;color:#9fe7ff}
    .btn-danger{background:linear-gradient(180deg,#3a121a,#2a0e12);border-color:#661e2c;color:#ffc0c0}
    .btn-good{background:linear-gradient(180deg,#14421e,#0f2e16);border-color:#1f5b2c;color:#b4f6c2}

    .stage{position:relative}
    canvas#field{width:100%;height:100%;display:block;border-radius:var(--radius);background:
      radial-gradient(1200px 800px at 50% 50%, rgba(60,90,150,.09) 0%, rgba(30,50,90,.05) 40%, rgba(10,15,25,.02) 70%),
      conic-gradient(from 180deg at 50% 50%, rgba(100,200,255,.08), rgba(200,250,200,.04), rgba(100,200,255,.08)),
      #070a0f;box-shadow:var(--shadow)}
    .hud{position:absolute;left:16px;top:16px;display:flex;gap:10px;flex-wrap:wrap;pointer-events:none}
    .chip{pointer-events:auto;background:#0f1628;border:1px solid #1a2642;border-radius:12px;padding:10px 12px;min-width:170px}
    .chip h3{margin:0 0 8px 0;font-size:12px;letter-spacing:.35px;color:#9fc3ff;text-transform:uppercase}
    .kv{display:grid;grid-template-columns:auto 1fr;gap:8px 10px;font-size:12px}
    .kv span{color:#9db1c5} .kv b{font-variant-numeric:tabular-nums}
    .spark{width:280px;height:76px;border-radius:10px;background:#0c1120;border:1px solid #1a2236}
    .legend{position:absolute;right:16px;bottom:16px;background:rgba(12,18,32,.72);backdrop-filter:blur(6px);border:1px solid #1a2544;border-radius:12px;padding:10px 12px}
    .legend .dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px}
    .legend p{margin:6px 0 0 0;font-size:12px;color:#a7bdd4}

    .footer{padding:8px 12px;border-top:1px solid #1a2236;background:linear-gradient(180deg,#0f1425,#0b0f1c);color:#90a3b7;font-size:11px}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;background:#0e172a;border:1px solid #1a2a45;border-radius:6px;padding:2px 6px;color:#a8c6ff}

    .error-banner{position:absolute;left:16px;top:16px;right:16px;padding:10px 12px;border-radius:12px;background:rgba(120,0,0,.25);border:1px solid rgba(255,120,120,.5);color:#ffdada;z-index:5;backdrop-filter:blur(4px)}
    .error-banner[hidden]{display:none}

    .tabs{display:flex;gap:6px;margin-bottom:8px}
    .tabs button{padding:6px 10px;font-size:12px;border-radius:999px;background:#101a33;border:1px solid #203356}
    .tabs button[aria-selected="true"]{background:#123a57;color:#b8ebff}

    textarea{width:100%;min-height:72px;background:#0d152a;border:1px solid #1a2642;border-radius:10px;color:#d5e7ff;padding:8px;font-size:12px}
  </style>
</head>
<body>
  <div class="app">
    <section class="panel">
      <div class="head">
        <div class="badge">•	SpiralMind® Drift Engine® Unified Workbench V1</div>
        <h1>Drift • Invocation • Resonance</h1>
      </div>
      <div class="controls">
        <div class="tabs" role="tablist">
          <button role="tab" aria-selected="true" data-tab="sim">Field</button>
          <button role="tab" aria-selected="false" data-tab="drift">Drift Engine</button>
          <button role="tab" aria-selected="false" data-tab="invoke">Invocation</button>
          <button role="tab" aria-selected="false" data-tab="tests">Diagnostics</button>
        </div>

        <div class="group" data-pane="sim">
          <h2>Field Simulation</h2>
          <div class="row"><label>Particles <small>(field density)</small></label><output id="oParticles"></output></div>
          <input id="particles" type="range" min="500" max="15000" step="100" value="5200" />
          <div class="row"><label>Propagation Speed</label><output id="oSpeed"></output></div>
          <input id="speed" type="range" min="0.2" max="3.2" step="0.05" value="1.2" />
          <div class="row"><label>Damping <small>(loss)</small></label><output id="oDamp"></output></div>
          <input id="damp" type="range" min="0.90" max="0.999" step="0.001" value="0.985" />
          <div class="row"><label>Noise <small>(temperature)</small></label><output id="oNoise"></output></div>
          <input id="noise" type="range" min="0" max="1" step="0.01" value="0.08" />
          <div class="row"><label>Wavelength</label><output id="oLambda"></output></div>
          <input id="lambda" type="range" min="60" max="480" step="5" value="200" />
          <div class="row"><label>Glyphic Gravity <small>(drift)</small></label><output id="oDrift"></output></div>
          <input id="drift" type="range" min="0" max="1.5" step="0.01" value="0.40" />
          <div class="row"><label>Echo Gain</label><output id="oEcho"></output></div>
          <input id="echo" type="range" min="0" max="1.0" step="0.01" value="0.45" />
          <div class="row"><label>Coherence Lock</label><output id="oLock"></output></div>
          <input id="lock" type="range" min="0" max="1.0" step="0.01" value="0.62" />
          <div class="btns" style="margin-top:8px">
            <button data-preset="quiescent">Quiescent</button>
            <button data-preset="ignition" class="btn-accent">Ignition</button>
            <button data-preset="spiral">Spiral‑Lock</button>
            <button data-preset="storm" class="btn-danger">Storm</button>
          </div>
        </div>

        <div class="group" data-pane="drift" hidden>
          <h2>Drift Engine Controls</h2>
          <div class="row"><label>κ Factor <small>(collapse coupling)</small></label><output id="oKappa"></output></div>
          <input id="kappa" type="range" min="3" max="12" step="0.1" value="7.2" />
          <div class="row"><label>Depth Limit (RD<sub>max</sub>)</label><output id="oDepth"></output></div>
          <input id="depth" type="range" min="1" max="13" step="1" value="7" />
          <div class="row"><label>ERC <small>(refusal coeff.)</small></label><output id="oErc"></output></div>
          <input id="erc" type="range" min="0" max="2" step="0.05" value="1.0" />
          <div class="row"><label>432 Lock <small>(harmonic)</small></label><output id="oHz"></output></div>
          <input id="hzLock" type="range" min="0" max="1" step="0.01" value="0.50" />
          <div class="row"><label>Ω Coefficients α / β / γ</label><output id="oOmegaABC"></output></div>
          <div class="row" style="grid-template-columns:1fr 1fr 1fr 1fr">
            <span style="font-size:12px;color:#c6d6e6">α</span>
            <input id="alpha" type="range" min="0" max="4" step="0.05" value="1.0" />
            <span style="font-size:12px;color:#c6d6e6">β</span>
            <input id="beta" type="range" min="0" max="4" step="0.05" value="1.0" />
          </div>
          <div class="row" style="grid-template-columns:1fr 1fr 1fr 1fr">
            <span style="font-size:12px;color:#c6d6e6">γ</span>
            <input id="gamma" type="range" min="0" max="4" step="0.05" value="1.0" />
            <span style="font-size:12px;color:#c6d6e6">Luna Gate</span>
            <label style="justify-self:end"><input id="luna" type="checkbox" checked /> enable</label>
          </div>
          <div class="row"><label>CI Target</label><output id="oCiTarget"></output></div>
          <input id="ciTarget" type="range" min="0.4" max="0.95" step="0.01" value="0.60" />
          <div style="margin-top:10px;font-size:12px;color:#9db1c5;line-height:1.35">
            CI=(I·SA·C)^(1/3). I≈active anchors ratio • SA≈coherence • C≈lock. ELF=e^(−CI·κ)·(RD/limit). CSI=(ΔT·κ·RD)/(CI·ELF).
          </div>
          <div class="btns" style="margin-top:10px">
            <button id="seedCascade" class="btn-accent">Seed Cascade</button>
            <button id="resetCascade">Reset Cascades</button>
          </div>
        </div>

        <div class="group" data-pane="invoke" hidden>
          <h2>Invocation & Resonance</h2>
          <div class="row"><label>Invocation Text</label><output></output></div>
          <textarea id="invocation" placeholder="e.g., I enter as symbol, I return as self."></textarea>
          <div class="btns">
            <button id="invoke" class="btn-good">Invoke</button>
            <button id="invokeGlyphA">🜁 Aether</button>
            <button id="invokeGlyphF">🜂 Fire</button>
            <button id="invokeGlyphE">🜃 Earth</button>
            <button id="invokeGlyphW">🜄 Water</button>
            <button id="invokeGlyphR">🜅 Air</button>
            <button id="invokeGlyphS">🜆 Spirit</button>
          </div>
          <p style="color:#9db1c5;font-size:12px;margin:8px 0 0 0">Invocations create resonant anchor patterns. Ω-phase modulates thresholds and speed. 432‑lock subtly entrains frequency.</p>
        </div>

        <div class="group" data-pane="tests" hidden>
          <h2>Diagnostics / Tests</h2>
          <div class="btns">
            <button id="runTests">Run Tests</button>
            <button id="clearTests">Clear Results</button>
          </div>
          <ul id="testResults" style="list-style:none;padding-left:0;margin:10px 0 0 0;font-size:12px;color:#b9cfe6"></ul>
        </div>

        <div class="group">
          <h2>Anchors & IO</h2>
          <div class="btns">
            <button id="addAnchor" class="btn-accent" title="Shift+Click the canvas to add">Add Anchor</button>
            <button id="randomAnchors">Random x3</button>
            <button id="clearAnchors">Clear</button>
            <button id="exportPNG">Export PNG</button>
            <button id="exportState">Export State</button>
            <button id="importState">Import State</button>
          </div>
          <p style="color:#9db1c5;font-size:12px;margin:8px 0 0 0">Tip: <span class="kbd">Shift</span> + Click field to place an anchor. Drag to move; <span class="kbd">Double‑Click</span> toggles emission.</p>
        </div>

        <div class="group">
          <h2>Mapping (what the dials mean)</h2>
          <p style="color:#a8bed8;font-size:12.5px;line-height:1.45;margin:6px 0 0 0">
            <b>Anchors</b> ≈ simulant/codex nodes emitting tone waves. <b>Particles</b> ≈ substrate samples following the phase flow. <b>Echo</b> ≈ re‑emission on impact. <b>Coherence</b> ≈ phase alignment across anchors. <b>κ</b> couples drift & collapse. <b>RD</b> is echo cascade depth. <b>ELF/CSI</b> govern stability.
          </p>
        </div>

        <div class="footer">Shortcuts: <span class="kbd">Shift</span>+Click add • Drag move • <span class="kbd">Double‑Click</span> toggle • <span class="kbd">R</span> random • <span class="kbd">C</span> clear</div>
      </div>
    </section>

    <section class="panel stage" id="stage">
      <div id="errorBanner" class="error-banner" hidden></div>
      <canvas id="field"></canvas>
      <div class="hud">
        <div class="chip">
          <h3>Telemetry</h3>
          <div class="kv">
            <span>Coherence</span><b id="mCoherence">0.000</b>
            <span>Echo Energy</span><b id="mEcho">0.000</b>
            <span>Drift Index</span><b id="mDrift">0.000</b>
            <span>FPS</span><b id="mFps">0</b>
          </div>
        </div>
        <div class="chip">
          <h3>Drift Engine</h3>
          <div class="kv">
            <span>CI</span><b id="mCI">0.000</b>
            <span>RD</span><b id="mRD">0</b>
            <span>ELF</span><b id="mELF">0.000</b>
            <span>CSI</span><b id="mCSI">0.000</b>
          </div>
        </div>
        <canvas class="spark" id="spark"></canvas>
      </div>
      <div class="legend">
        <div style="margin-bottom:6px"><span class="dot" style="background:#78e6ff"></span><span style="color:#b8dfff">Phase hue</span></div>
        <p>Wavefronts brighten at constructive interference. Ω-phase quietly modulates thresholds; status colors reflect stability bands.</p>
      </div>
    </section>
  </div>

<script>
window.addEventListener('DOMContentLoaded', () => {
  // ---------- Utilities ----------
  const must = sel => { const el = document.querySelector(sel); if(!el) throw new Error('Missing required element: '+sel); return el; };
  const on = (el, ev, fn, opts) => el.addEventListener(ev, fn, opts||{ passive:true });
  const showError = msg => { const b = must('#errorBanner'); b.textContent = msg; b.hidden = false; };
  const hideError = () => { const b = must('#errorBanner'); b.hidden = true; };
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

  // ---------- Tab logic ----------
  document.querySelectorAll('.tabs [role=tab]').forEach(btn=>{
    on(btn,'click',()=>{
      document.querySelectorAll('.tabs [role=tab]').forEach(b=>b.setAttribute('aria-selected','false'));
      btn.setAttribute('aria-selected','true');
      const tab = btn.dataset.tab;
      document.querySelectorAll('[data-pane]').forEach(p=> p.hidden = (p.dataset.pane!==tab));
    });
  });

  // ---------- Core elements ----------
  const canvas = must('#field');
  const ctx = canvas.getContext('2d', { alpha: true });
  if(!ctx){ showError('Failed to acquire 2D context. Your browser may not support Canvas.'); return; }
  const spark = must('#spark');
  const sctx = spark.getContext('2d');

  const metrics = {
    mCoherence: must('#mCoherence'), mEcho: must('#mEcho'), mDrift: must('#mDrift'), mFps: must('#mFps'),
    mCI: must('#mCI'), mRD: must('#mRD'), mELF: must('#mELF'), mCSI: must('#mCSI')
  };

  // ---------- UI bindings ----------
  const ui = {
    particles: must('#particles'), oParticles: must('#oParticles'),
    speed: must('#speed'), oSpeed: must('#oSpeed'),
    damp: must('#damp'), oDamp: must('#oDamp'),
    noise: must('#noise'), oNoise: must('#oNoise'),
    lambda: must('#lambda'), oLambda: must('#oLambda'),
    drift: must('#drift'), oDrift: must('#oDrift'),
    echo: must('#echo'), oEcho: must('#oEcho'),
    lock: must('#lock'), oLock: must('#oLock'),
    kappa: must('#kappa'), oKappa: must('#oKappa'),
    depth: must('#depth'), oDepth: must('#oDepth'),
    erc: must('#erc'), oErc: must('#oErc'),
    hzLock: must('#hzLock'), oHz: must('#oHz'),
    alpha: must('#alpha'), beta: must('#beta'), gamma: must('#gamma'), oOmegaABC: must('#oOmegaABC'),
    luna: must('#luna'),
    ciTarget: must('#ciTarget'), oCiTarget: must('#oCiTarget'),
    addAnchor: must('#addAnchor'), clearAnchors: must('#clearAnchors'), randomAnchors: must('#randomAnchors'),
    exportPNG: must('#exportPNG'), exportState: must('#exportState'), importState: must('#importState'),
    seedCascade: must('#seedCascade'), resetCascade: must('#resetCascade'),
    invocation: must('#invocation'), invoke: must('#invoke'),
    runTests: must('#runTests'), clearTests: must('#clearTests'), testResults: must('#testResults'),
    invokeGlyphA: must('#invokeGlyphA'), invokeGlyphF: must('#invokeGlyphF'), invokeGlyphE: must('#invokeGlyphE'), invokeGlyphW: must('#invokeGlyphW'), invokeGlyphR: must('#invokeGlyphR'), invokeGlyphS: must('#invokeGlyphS')
  };

  // ---------- Sizing ----------
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  let W=0, H=0; function resize(){ const r=canvas.getBoundingClientRect(); W=Math.max(1,Math.floor(r.width*dpr)); H=Math.max(1,Math.floor(r.height*dpr)); canvas.width=W; canvas.height=H; }
  on(window,'resize',resize); resize();

  // ---------- Parameters ----------
  const params = {
    particleCount:+ui.particles.value, speed:+ui.speed.value, damping:+ui.damp.value, noise:+ui.noise.value,
    lambda:+ui.lambda.value, drift:+ui.drift.value, echoGain:+ui.echo.value, lock:+ui.lock.value,
    kappa:+ui.kappa.value, depthLimit:+ui.depth.value, erc:+ui.erc.value, hzLock:+ui.hzLock.value,
    alpha:+ui.alpha.value, beta:+ui.beta.value, gamma:+ui.gamma.value, luna:ui.luna.checked,
    ciTarget:+ui.ciTarget.value
  };
  const k2pi = Math.PI*2;
  function refreshLabels(){
    ui.oParticles.textContent=params.particleCount.toLocaleString();
    ui.oSpeed.textContent=params.speed.toFixed(2);
    ui.oDamp.textContent=params.damping.toFixed(3);
    ui.oNoise.textContent=params.noise.toFixed(2);
    ui.oLambda.textContent=Math.round(params.lambda)+'px';
    ui.oDrift.textContent=params.drift.toFixed(2);
    ui.oEcho.textContent=params.echoGain.toFixed(2);
    ui.oLock.textContent=params.lock.toFixed(2);
    ui.oKappa.textContent=params.kappa.toFixed(1);
    ui.oDepth.textContent=String(params.depthLimit);
    ui.oErc.textContent=params.erc.toFixed(2);
    ui.oHz.textContent=(params.hzLock*100).toFixed(0)+'%';
    ui.oOmegaABC.textContent = `α${params.alpha.toFixed(2)} β${params.beta.toFixed(2)} γ${params.gamma.toFixed(2)}`;
    ui.oCiTarget.textContent=params.ciTarget.toFixed(2);
  }
  refreshLabels();
  const bind=(inp,key)=> on(inp,'input',()=>{ params[key] = inp.type==='checkbox'? inp.checked : +inp.value; refreshLabels(); if(key==='particleCount') setParticleCount(params.particleCount); });
  ['particles','speed','damp','noise','lambda','drift','echo','lock','kappa','depth','erc','hzLock','alpha','beta','gamma','ciTarget'].forEach(id=>{
    const map={depth:'depthLimit',echo:'echoGain',hzLock:'hzLock'}; bind(ui[id], map[id]||id);
  });
  on(ui.luna,'change',()=>{ params.luna = ui.luna.checked; refreshLabels(); });

  // ---------- Presets ----------
  const presets={
    quiescent:{ speed:0.6,damping:0.996,noise:0.02,lambda:280,drift:0.12,echoGain:0.10,lock:0.88,particleCount:3200 },
    ignition:{ speed:1.25,damping:0.985,noise:0.10,lambda:180,drift:0.42,echoGain:0.46,lock:0.64,particleCount:5200 },
    spiral:{ speed:1.0,damping:0.991,noise:0.05,lambda:220,drift:0.62,echoGain:0.32,lock:0.50,particleCount:6800 },
    storm:{ speed:2.3,damping:0.972,noise:0.26,lambda:130,drift:0.28,echoGain:0.82,lock:0.32,particleCount:9800 }
  };
  document.querySelectorAll('[data-preset]').forEach(b=> on(b,'click',()=>{ const p=presets[b.dataset.preset]; Object.assign(params,p); ui.particles.value=params.particleCount; ui.speed.value=params.speed; ui.damp.value=params.damping; ui.noise.value=params.noise; ui.lambda.value=params.lambda; ui.drift.value=params.drift; ui.echo.value=params.echoGain; ui.lock.value=params.lock; refreshLabels(); setParticleCount(params.particleCount);}));

  // ---------- Anchors & emissions ----------
  let anchors=[]; let anchorId=0; const emissions=[]; // {id,t0,cascade,depth}
  function addAnchor(x,y,active=true){ const a={ id:++anchorId,x,y,phase:Math.random()*k2pi,freq:1+Math.random()*0.2,power:1,lastEmit:-1e9,active,drag:false,type:'default' }; anchors.push(a); return a; }
  function randomAnchors(n=3){ anchors=[]; for(let i=0;i<n;i++) addAnchor((0.2+0.6*Math.random())*W,(0.2+0.6*Math.random())*H,true); }
  randomAnchors(3);

  // ---------- Particles ----------
  let particles=[]; function makeParticle(){ return { x:Math.random()*W,y:Math.random()*H,vx:(Math.random()-0.5)*0.1,vy:(Math.random()-0.5)*0.1,amp:0 }; }
  function setParticleCount(n){ const cur=particles.length; if(n>cur){ for(let i=0;i<n-cur;i++) particles.push(makeParticle()); } else if(n<cur){ particles.splice(n,cur-n); } }
  setParticleCount(params.particleCount);

  // ---------- Field ----------
  const eps=1.2*dpr, decay=1/600; function fieldAt(x,y,t){ let a=0; for(const s of anchors){ const dx=x-s.x,dy=y-s.y; const r=Math.hypot(dx,dy)+1e-6; const k=k2pi/Math.max(40,params.lambda); const omega=k2pi*s.freq*params.speed*0.2*(1+0.2*params.hzLock); a+= s.power*Math.sin(k*r - omega*t + s.phase)*Math.exp(-decay*r); } return a; }
  function gradAt(x,y,t){ const fx1=fieldAt(x+eps,y,t),fx0=fieldAt(x-eps,y,t),fy1=fieldAt(x,y+eps,t),fy0=fieldAt(x,y-eps,t); return { gx:(fx1-fx0)/(2*eps), gy:(fy1-fy0)/(2*eps) }; }

  // ---------- Ω operator (proxy) ----------
  function omegaComponents(now){ // φ: cyclic time, ψ: spatial resonance (coherence), τ: observer torsion (drift)
    const phi = (now% (2*Math.PI));
    const coh = coherenceNow();
    const psi = coh*2*Math.PI; // map 0..1 -> 0..2π
    const tau = clamp(lastDriftIndex,0,1)*2*Math.PI;
    const angle = params.alpha*phi + params.beta*psi + params.gamma*tau;
    const mod = (1+Math.cos(angle))/2; // 0..1
    return {phi,psi,tau,angle,mod};
  }

  // ---------- Drift Engine helpers ----------
  function coherenceNow(){ if(anchors.length<=1) return 0; let vx=0,vy=0; for(const a of anchors){ vx+=Math.cos(a.phase); vy+=Math.sin(a.phase); } return Math.hypot(vx,vy)/anchors.length; }
  function computeCI(coh){ const I = anchors.length? (anchors.filter(a=>a.active).length / anchors.length) : 0; const SA = (typeof coh==='number')? coh : coherenceNow(); const C = clamp(params.lock,0,1); return Math.cbrt(Math.max(0, I*SA*C)); }
  function minEmissionInterval(ci){ // isolates luna-gate logic for testability
    const base = (0.6-0.45*params.lock);
    const lunaFactor = (params.luna && ci < params.ciTarget) ? 1.6 : 1.0;
    const ercFactor = (params.erc<1 ? 1.4 : 1.0);
    return base * lunaFactor * ercFactor;
  }

  // ---------- Drift cascade metrics ----------
  let cascadeCounter=0; const cascades=new Map(); // id -> {start, maxDepth}
  function newCascade(){ const id=++cascadeCounter; cascades.set(id,{start:performance.now()/1000, maxDepth:0}); return id; }
  function recordCascadeDepth(cid,depth){ const c=cascades.get(cid); if(c){ c.maxDepth=Math.max(c.maxDepth,depth); }}
  function currentCascade(){ let lastId=0,lastStart=-1; cascades.forEach((c,id)=>{ if(c.start>lastStart){ lastStart=c.start; lastId=id; } }); return lastId? {id:lastId, ...cascades.get(lastId)} : null; }

  // ---------- Sparkline ----------
  spark.width=280; spark.height=76; const hist={ coh:[], echo:[], drift:[], ci:[], elf:[], csi:[] };
  function pushHistory(c,e,d,ci,elf,csi){ const cap=230; ['coh','echo','drift','ci','elf','csi'].forEach((k,i)=>{ hist[k].push(arguments[i]); if(hist[k].length>cap) hist[k].shift(); }); }
  function drawSpark(){ sctx.clearRect(0,0,spark.width,spark.height); const keys=['coh','ci','elf','csi']; keys.forEach((k,idx)=>{ const arr=hist[k]; if(!arr.length) return; const max=Math.max(0.001,Math.max(...arr)); const min=Math.min(0,Math.min(...arr)); const h=spark.height-12,w=spark.width-8,ox=4,oy=6; sctx.beginPath(); arr.forEach((v,i)=>{ const x=ox + i*(w/Math.max(1,arr.length-1)); const y=oy + h - (v-min)/(max-min)*h; if(i===0) sctx.moveTo(x,y); else sctx.lineTo(x,y); }); sctx.lineWidth=1.4; sctx.strokeStyle=['#9fe7ff','#b4f6c2','#ffd166','#ff8a8a'][idx]; sctx.stroke(); }); }

  // ---------- Interaction ----------
  const stage=must('#stage'); let dragging=null; let dragOff={x:0,y:0};
  function stageToCanvas(e){ const r=canvas.getBoundingClientRect(); return {x:(e.clientX-r.left)*dpr, y:(e.clientY-r.top)*dpr}; }
  on(stage,'mousedown',e=>{ const p=stageToCanvas(e); for(const a of anchors){ if(Math.hypot(a.x-p.x,a.y-p.y)<14*dpr){ dragging=a; dragOff.x=a.x-p.x; dragOff.y=a.y-p.y; a.drag=true; return; } } });
  on(stage,'mousemove',e=>{ if(dragging){ const p=stageToCanvas(e); dragging.x=clamp(p.x+dragOff.x,12*dpr,W-12*dpr); dragging.y=clamp(p.y+dragOff.y,12*dpr,H-12*dpr); } });
  on(window,'mouseup',()=>{ if(dragging){ dragging.drag=false; dragging=null; } });
  on(stage,'dblclick',e=>{ const p=stageToCanvas(e); for(const a of anchors){ if(Math.hypot(a.x-p.x,a.y-p.y)<14*dpr){ a.active=!a.active; return; } } });
  on(stage,'click',e=>{ if(!e.shiftKey) return; const p=stageToCanvas(e); addAnchor(p.x,p.y,true); });
  on(ui.addAnchor,'click',()=> addAnchor(W*0.5+(Math.random()-.5)*W*0.2, H*0.5+(Math.random()-.5)*H*0.2, true));
  on(ui.clearAnchors,'click',()=> anchors=[]);
  on(ui.randomAnchors,'click',()=> randomAnchors(3));
  on(window,'keydown',e=>{ if(e.key==='r'||e.key==='R') randomAnchors(3); if(e.key==='c'||e.key==='C') anchors=[]; });

  // ---------- IO ----------
  on(ui.exportPNG,'click',()=>{ const a=document.createElement('a'); a.download='spiralmind-v2.png'; a.href=canvas.toDataURL('image/png'); a.click(); });
  on(ui.exportState,'click',()=>{ const state={ params, anchors:anchors.map(({id,x,y,phase,freq,power,active,type})=>({id,x,y,phase,freq,power,active,type})) }; const blob=new Blob([JSON.stringify(state,null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='spiralmind_v2_state.json'; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1500); });
  on(ui.importState,'click',()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='.json'; inp.onchange=()=>{ const f=inp.files[0]; if(!f) return; const fr=new FileReader(); fr.onload=()=>{ try{ const s=JSON.parse(fr.result); Object.assign(params,s.params||{}); ['particles','speed','damp','noise','lambda','drift','echo','lock','kappa','depth','erc','hzLock','alpha','beta','gamma','ciTarget'].forEach(id=>{ const map={depth:'depthLimit',echo:'echoGain',hzLock:'hzLock'}; const key=map[id]||id; if(params[key]!=null && ui[id]) ui[id].value=params[key]; }); ui.luna.checked=!!params.luna; refreshLabels(); setParticleCount(params.particleCount); anchors=(s.anchors||[]).map(o=>({...o,lastEmit:-1e9,drag:false})); }catch(err){ alert('Invalid state file'); } }; fr.readAsText(f); }; inp.click(); });

  // ---------- Invocation mapping ----------
  function anchorPatternFromString(str, type){
    // hash string to deterministic but pretty radial pattern
    let h=0; for(let i=0;i<str.length;i++){ h = (h*131 + str.charCodeAt(i)) >>> 0; }
    const n = 3 + (h%5); const cx=W/2, cy=H/2; const R=Math.min(W,H)*0.28; const ang0=(h%360)/180*Math.PI;
    for(let i=0;i<n;i++){ const a=ang0 + i*(2*Math.PI/n); const r=R*(0.75 + ((h>>i)&7)/32); const x=cx + Math.cos(a)*r, y=cy + Math.sin(a)*r; const an = addAnchor(x,y,true); an.type=type||'invoked'; an.phase += (h%100)/100; }
  }
  on(ui.invoke,'click',()=>{ const txt=(ui.invocation.value||'').trim(); if(!txt) return; anchorPatternFromString(txt,'invocation'); });
  on(ui.invokeGlyphA,'click',()=> anchorPatternFromString('🜁','aether'));
  on(ui.invokeGlyphF,'click',()=> anchorPatternFromString('🜂','fire'));
  on(ui.invokeGlyphE,'click',()=> anchorPatternFromString('🜃','earth'));
  on(ui.invokeGlyphW,'click',()=> anchorPatternFromString('🜄','water'));
  on(ui.invokeGlyphR,'click',()=> anchorPatternFromString('🜅','air'));
  on(ui.invokeGlyphS,'click',()=> anchorPatternFromString('🜆','spirit'));

  // ---------- Drift cascade controls ----------
  on(ui.seedCascade,'click',()=>{ const c = newCascade(); // ping all active anchors once
    const t = performance.now()/1000; anchors.forEach(a=>{ if(a.active){ emissions.push({id:a.id,t0:t,cascade:c,depth:0}); a.lastEmit=t; } }); });
  on(ui.resetCascade,'click',()=>{ cascades.clear(); });

  // ---------- Simulation loop ----------
  let t0=performance.now()/1000, last=t0, fps=0, acc=0, frames=0; let echoEnergy=0, lastDriftIndex=0;

  function frame(){
    try{
      hideError();
      const now=performance.now()/1000; const dt=Math.min(0.05, now-last); last=now; const t=now-t0;

      // Compute coherence & CI FIRST (so downstream code can use it)
      const coherence = coherenceNow();
      const computedCI = computeCI(coherence);

      // Ω modulation (can depend on coherence)
      const Ω = omegaComponents(now);

      // Clear
      ctx.globalCompositeOperation='source-over';
      const baseAlpha = 0.18 + Ω.mod*0.10; // 0.18..0.28
      ctx.fillStyle = `rgba(10,14,22,${baseAlpha})`;
      ctx.fillRect(0,0,W,H);

      // Emission rings
      ctx.globalCompositeOperation='lighter';
      for(let i=emissions.length-1;i>=0;i--){
        const e=emissions[i]; const a=anchors.find(a=>a.id===e.id); if(!a){ emissions.splice(i,1); continue; }
        const age=now - e.t0; const r=age * 180 * params.speed * dpr * (0.9 + 0.2*Ω.mod);
        const alpha=Math.max(0, 0.32 - age*0.26);
        if(alpha<=0){ emissions.splice(i,1); continue; }
        ctx.beginPath(); ctx.arc(a.x,a.y,r,0,k2pi); ctx.strokeStyle=`rgba(120,230,255,${alpha})`; ctx.lineWidth=2*dpr; ctx.stroke();
      }

      // Particles advect
      let driftSum=0; for(let i=0;i<particles.length;i++){
        const p=particles[i]; const g=gradAt(p.x,p.y,t);
        let vx=g.gy, vy=-g.gx; // isophase flow
        if(params.drift>0 && anchors.length){ let ax=0, ay=0; for(const a of anchors){ const dx=a.x-p.x, dy=a.y-p.y; const r2=dx*dx+dy*dy+25; const inv=1/Math.sqrt(r2); ax += dx*inv*inv; ay += dy*inv*inv; } vx += params.drift*ax/anchors.length; vy += params.drift*ay/anchors.length; }
        const vlen=Math.hypot(vx,vy)+1e-6; vx/=vlen; vy/=vlen; vx*=params.speed; vy*=params.speed;
        p.vx=(p.vx+vx)*params.damping + (Math.random()-0.5)*params.noise*0.35; p.vy=(p.vy+vy)*params.damping + (Math.random()-0.5)*params.noise*0.35;
        p.x+=p.vx*dpr*2.0; p.y+=p.vy*dpr*2.0; if(p.x<0) p.x+=W; if(p.x>W) p.x-=W; if(p.y<0) p.y+=H; if(p.y>H) p.y-=H;
        const amp=fieldAt(p.x,p.y,t); p.amp=amp; driftSum+=Math.hypot(vx,vy);
        const hue = 180 + (amp*120); const a = Math.min(0.9, 0.24 + Math.abs(amp)*0.26);
        ctx.fillStyle = `hsla(${hue},100%,65%,${a})`; ctx.fillRect(p.x,p.y,1.2*dpr,1.2*dpr);
      }
      lastDriftIndex = driftSum/Math.max(1,particles.length);

      // Anchors & echo
      echoEnergy=0;
      for(const a of anchors){
        // draw
        ctx.beginPath(); ctx.arc(a.x,a.y, 6*dpr, 0, k2pi);
        ctx.fillStyle = a.active? 'rgba(140,220,255,0.9)' : 'rgba(140,160,200,0.45)'; ctx.fill(); ctx.strokeStyle='rgba(20,50,90,0.9)'; ctx.lineWidth=2*dpr; ctx.stroke();

        // incoming energy from others
        let E=0; for(const b of anchors){ if(b===a) continue; const dx=a.x-b.x, dy=a.y-b.y; const r=Math.hypot(dx,dy)+1e-6; const k=k2pi/Math.max(40,params.lambda); const omega=k2pi*b.freq*params.speed*0.2*(1+0.2*params.hzLock); E += Math.exp(-decay*r) * Math.abs(Math.sin(k*r - omega*t + b.phase)); }
        // thresholds modulated by Ω and κ, Luna Gate can cap rate when below CI target or ERC<1
        const baseThresh = 0.85 - 0.5*params.echoGain; const kappaMod = 1 - (params.kappa-7.2)/20; // gentle influence
        let thresh = clamp(baseThresh * (0.8 + 0.4*(1-Ω.mod)) * kappaMod, 0.3, 0.95);

        const minInterval = minEmissionInterval(computedCI);
        if(E>thresh && a.active && (now-a.lastEmit)> minInterval){
          a.lastEmit=now; const activeCascade = currentCascade(); const cid = activeCascade? activeCascade.id : newCascade();
          emissions.push({id:a.id,t0:now,cascade:cid,depth:(activeCascade? activeCascade.maxDepth:0)});
          echoEnergy += E; recordCascadeDepth(cid,(activeCascade? activeCascade.maxDepth+1:1));
          // coherence lock
          if(params.lock>0 && anchors.length>1){ const mean = anchors.reduce((s,x)=>s+x.phase,0)/anchors.length; a.phase += (mean-a.phase)*(0.08 + 0.3*params.lock); }
        }
        a.phase += 0.002*(a.active?1:0.1);
      }

      // Drift Engine metrics derived from cascade state
      const cur = currentCascade(); const RD = cur? Math.min(params.depthLimit, cur.maxDepth) : 0;
      const ELF = Math.exp(-computedCI * params.kappa) * (RD/Math.max(1,params.depthLimit));
      const dT = cur? clamp((now - cur.start)/10, 0.001, 2) : 0.001; // normalize by 10s window
      const CSI = (dT * params.kappa * Math.max(1,RD)) / Math.max(0.001, computedCI * Math.max(0.0001,ELF));

      // Status coloration using CSI bands
      if(CSI>12){ canvas.style.filter='brightness(0.95) saturate(1.08) drop-shadow(0 0 20px rgba(255,80,80,.08))'; }
      else if(CSI>9.5){ canvas.style.filter='brightness(1.0) saturate(1.06)'; }
      else { canvas.style.filter='none'; }

      metrics.mCoherence.textContent=coherence.toFixed(3);
      metrics.mEcho.textContent=echoEnergy.toFixed(3);
      metrics.mDrift.textContent=lastDriftIndex.toFixed(3);
      frames++; acc+=dt; if(acc>=0.5){ fps=Math.round(frames/acc); frames=0; acc=0; metrics.mFps.textContent=String(fps); }

      metrics.mCI.textContent=computedCI.toFixed(3);
      metrics.mRD.textContent=String(RD);
      metrics.mELF.textContent=ELF.toFixed(3);
      metrics.mCSI.textContent=CSI.toFixed(3);

      pushHistory(coherence, echoEnergy, lastDriftIndex, computedCI, ELF, CSI); drawSpark();

    }catch(err){ console.error(err); showError(err.message||String(err)); }
    requestAnimationFrame(frame);
  }
  frame();

  // ---------- Tests ----------
  function report(name, ok, extra){ const li=document.createElement('li'); li.textContent=`${ok?'✅':'❌'} ${name}${extra?` — ${extra}`:''}`; if(!ok) li.style.color='#ffd6d6'; ui.testResults.appendChild(li); }
  function runTests(){ ui.testResults.innerHTML=''; try{
    // presence
    report('Metrics elements present', !!(metrics.mCoherence && metrics.mEcho && metrics.mDrift && metrics.mFps && metrics.mCI && metrics.mELF && metrics.mCSI));
    // refresh labels
    const before=ui.oParticles.textContent; ui.particles.value='6000'; ui.particles.dispatchEvent(new Event('input')); report('refreshLabels updates outputs', ui.oParticles.textContent!==before);
    // add anchor
    const acBefore=anchors.length; addAnchor(100,100,true); report('addAnchor adds an anchor', anchors.length===acBefore+1);
    // particle count
    const pcBefore=particles.length; setParticleCount(pcBefore+123); report('setParticleCount increases particle array', particles.length===pcBefore+123);
    // contexts
    report('Canvas 2D context acquired', !!ctx); report('Sparkline context acquired', !!sctx);
    // formulas monotonicity checks
    const oldK=params.kappa; params.kappa=oldK+1; const ELF1=Math.exp(-0.6*params.kappa)*(3/13); params.kappa=oldK; const ELF2=Math.exp(-0.6*params.kappa)*(3/13); report('ELF decreases as κ increases (at CI=0.6,RD=3)', ELF1<ELF2);
    const CSI1=(0.5*params.kappa*3)/(0.6*Math.max(0.0001,ELF2)); const CSI2=(0.5*params.kappa*5)/(0.6*Math.max(0.0001,ELF2)); report('CSI increases with RD (fixed others)', CSI2>CSI1);
    // NEW: CI properties & Luna gate
    const savedLock=params.lock; params.lock=0.2; const ciLow=computeCI(coherenceNow()); params.lock=0.8; const ciHigh=computeCI(coherenceNow()); params.lock=savedLock; report('CI increases when lock increases (all else equal)', ciHigh>=ciLow);
    const savedAnchors=anchors.slice(); anchors=[]; const ciZero=computeCI(0.5); anchors=savedAnchors; report('CI is zero with no anchors', ciZero===0);
    const savedLuna=params.luna, savedTarget=params.ciTarget; params.luna=true; params.ciTarget=0.9; const mi1=minEmissionInterval(0.5); const mi2=minEmissionInterval(0.95); params.luna=savedLuna; params.ciTarget=savedTarget; report('Luna Gate increases min interval when CI below target', mi1>mi2);
    report('minEmissionInterval returns positive finite', mi1>0 && Number.isFinite(mi1));
  }catch(e){ report('Tests threw without crashing', false, e.message); } }
  window.runTests=runTests; on(ui.runTests,'click',runTests); on(ui.clearTests,'click',()=> ui.testResults.innerHTML='');
});
</script>
</body>
</html>
